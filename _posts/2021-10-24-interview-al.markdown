---
layout: post
title:  "算法&数据结构"
date:   2021-10-24 18:01:50 +0800
categories: 面试
---

* 算法设计、算法分析

  - 树

    递归、迭代、深度优先、广度优先、栈

  - 动态规划

    一般是设计一个表，后边的值依赖前边的值

* 排序

* 字符串

* 数组

* 链表

* 哈希表

  例：大量IP地址的查找

  python 中 set dict 就是很好的 hash 表

* 位运算

  - 优先级 ~、 >><<、&、  ^  |、
  - a | b & a = (a | b) & a = a, a & b | a = a, a ^ a = 0, 0 ^ a = a

* 树

  - 通用树的概念：

    - 深度 高度 节点 根节点 叶子节点 

    * 度数：在树中，每个节点的子节点（子树）的个数就称为该节点的度（degree）。

    * 阶数：（Order）阶定义为一个节点的子节点数目的最大值。（自带最大值属性）
    * 先序遍历/深度优先/根-左-右、中序遍历、后序遍历、按层遍历/广度优先

  * 二叉树（最多两个子节点）、~~二叉堆~~、 Treap、二叉查找树(BST)、 平衡二叉树（AVL)、伸展树、  红黑树 ...

    * 二叉堆：将数组以二叉树的形式表示出来，满足根节点是数组的最大/小值

    * Treap：每一个节点随机对应一个优先级，通过旋转使满足父节点的优先级大/小于子节点的优先级

    * 二叉查找树：左子树的值小于节点值，右子树的值大于节点值

    * 平衡二叉树：是一个二叉查找树，满足任意子树到叶子节点的高度之差小于等于1

    * 红黑树：是一个接近的平衡二叉树

      （1）每个节点或者是黑色，或者是红色。
      （2）根节点是黑色。

      （3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]

      （4）如果一个节点是红色的，则它的子节点必须是黑色的。

      （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 

  * 增删节点，如何维持树规则

    * Treap
      * 增加：左旋右旋
      * 删除：只有一个子节点，直接删除，接上子节点；两个子节点，将要删除的节点旋转到只有一个子节点后，删除该节点
      * 二叉查找树
        * 增加：递归判断大小，添加节点
        * 删除：只有一个子节点，直接删除，接上子节点；两个子节点，找到最节点子节点后交换，删除被交换的节点
      * 平衡二叉树
        * 增加：同二叉查找树，添加节点后，找到最近失衡父节点，旋转以平衡子树高度
        * 删除：同二叉查找树，删除节点后，找到最近失衡父节点，旋转以平衡子树高度
      * 红黑树：
        * 增加：增加节点设置为红色，加后续不同case下的旋转操作，核心思路是将红色的节点移到根节点，然后将根节点设为黑色
        * 删除：将红黑树当作一颗二叉查找树，将节点删除，通过"旋转和重新着色"等一系列来修正该树，使之重新成为一棵红黑树。

  * 查询：O(lgn)

* 多个子节点：B树 --> B+ --> B*

  * B 树，是一个多路平衡树，降低树的高度

    * 用阶定义

      1. 树中每个结点最多含有m个孩子（m>=2）；
      2. 除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；
      3. 若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；
      4. 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)；
      5. 每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，......，Kn，Pn)。其中：
              a)   Ki (i=1...n)为关键字，且关键字按顺序升序排序K(i-1)< Ki。
              b)   Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。 
              c)   关键字的个数n必须满足： [ceil(m / 2)-1]<= n <= m-1。

    * 用度定义

    * 节点结构

      ```
      #define m 1024
      struct BTNode;
      typedef struct BTNode *PBTNode;
      struct BTNode{
      		int keynum;				 # 关键字数量
        	PBTNode parent;		# 父节点
      		PBTNode *childnode; # 子树指针向量
        	KeyType *key;			 # 关键字指针向量
      }
      ```

  - B +，与B树区别

    1. 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接；
    2. 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字
    3. 索引节点更小，磁盘I/O的读取效率、方便了范围查找和遍历

    - B \* 
      1. 在 B+ 树的基础上(所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针)，B*树中非根和非叶子结点再增加指向兄弟的指针；*
      2. B \* 树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）

* 堆栈队列

  - 队列

    队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表，是一种可以实现【先进先出】的存储结构。

    实现：数组 链表

  - 栈

    栈是限定仅在表尾进行插入和删除操作的线性表，是一种可以实现【先进后出】的存储结构。

    栈的应用：递归

    实现：数组 链表

  - 堆

    堆是一种经过排序的树形数据结构，每个节点都有一个值，通常我们所说的堆的数据结构是指二叉树。所以堆在数据结构中通常可以被看做是一棵树的数组对象。而且堆需要满足一下两个性质：
    （1）堆中某个节点的值总是不大于或不小于其父节点的值；
    （2）堆总是一棵完全二叉树。

    堆的存取是【任意】的

    实现：二叉树