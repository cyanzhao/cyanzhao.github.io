---
layout: post
title:  "计算机公共基础"
date:   2021-10-24 18:01:50 +0800
categories: 面试
---

* 计算机原理

  * 计算机原理--程序执行过程（计算机是怎么跑起来的）

* 操作系统

  * 操作系统--linux

    - 架构

      <img src="https://github.com/cyanzhao/cyanzhao.github.io/raw/master/_source/linux 架构.jpg" alt="linux 架构" style="zoom:40%;" />

      ![linux 内核架构](https://github.com/cyanzhao/cyanzhao.github.io/raw/master/_source/linux 内核架构.png)

    - ~~文件系统~~

  * 程序执行调度

    - **进程**

      - 是一个具有一定功能的程序在一个数据集上的一次动态执行过程。

      * 在内存中的数据结构

        进程由**程序，数据集合和进程控制块**三部分组成。
        程序用于描述进程要完成的功能，是控制进程执行的指令集；
        数据集合是程序在执行时需要的数据和工作区；
        程序控制块（PCB）包含程序的描述信息和控制信息，是进程存在的唯一标志。

      * 进程的几种状态

        | 标识 | 说明                                                         |
        | ---- | ------------------------------------------------------------ |
        | R    | 正在运行或者在运行队列中等待                                 |
        | S    | 中断（休眠中，受阻，在等待某个条件的形成或接收到信号）       |
        | D    | 不可中断（收到信号不唤醒和不可运行，进程必须等待直到有中断发生） |
        | Z    | 僵死（进程已终止，但是进程描述符仍存在，直到父进程调用wait4() 后释放） |
        | T    | 停止（进程收到SIGSTOP, SIGSTP, SIGTIN, SIGOUT 信号后停止运行） |

    * 线程

      * 是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。

      * 在内存中的数据结构

        复用进程的地址空间，数据空间，资源描述符表（~~ps：未必所有的数据空间都是复用的，线程应该有自己独立的栈~~）

      * 线程的几种状态

        * 新建

        * 可运行的，被调度算法执行

        * 正在运行

        * 阻塞 synchronized  I/O_block

        * 等待 wait()  join()  sleep()

        * 终止 

          ![thread_status](https://github.com/cyanzhao/cyanzhao.github.io/raw/master/_source/thread_status.png)

      * 守护线程 vs 工作线程

        当主线程只剩下守护线程时，主线程退出 

    * **进程线程的另一种描述：**进程和线程都是一个时间段（或者指令条数）的描述，是CPU工作时间段的描述，不过是颗粒大小不同。
      进程就是包换上下文切换的程序，执行时间总和 = CPU加载上下文+CPU执行+CPU保存
      线程是CPU执行的时间片时间

    * 进程线程调度实现

      在linux采用相同的调度技术，即存在优先级的红黑树数据结构；

      处于阻塞状态或者等待状态的线程，只有解除状态后才进入调度队列

    * 例程：

      - 过程、函数、方法、子程序被定义为操作的序列。

        例程的执行形成了父子关系，且孩子例程总是在父例程前结束。
        也即压栈弹栈式函数调用

    * 协程：

      - 是例程的范化概念。协程通过保持执行状态可以明确的挂起和恢复，每个协程拥有自己的栈和控制块(control-block)。
        也即将协程状态可以在挂起时在独立的栈中保留，在恢复时从栈中恢复到主栈

      - 特征区分

        控制传递（Control-transfer）机制

        协程是否为栈式（Stackful）构造

        协程是否作为语言的第一类（First-class）对象提供

    * 锁（即线程同步机制）

      多线程下，为了线程同步，避免资源竞争问题，可以使用原子操作或

      者锁机制。

      锁是一种非强制机制，每一个线程访问数据或资源之前，首先试图获

      取(Acquireuytreewq)锁,并在访问结束之后释放(release)。在锁已经被

      占用时获取锁，线程会等待，直到该锁被释放。

    * 通信

      - 进程间通信，在内核态交换数据

        共享内存

        消息队列

        信号（signal）、 信号量、

        管道（pipe），流管道(s_pipe)和有名管道（FIFO）

        套接字（socket)，可用于不同计算机间进程的通信

      * 线程间通信：主要要解决线程同步（数据竞争）问题和线程间控制问题

        * 互斥锁提供了以排他方式防止数据结构被并发修改的方法。

          * 属于sleep-waiting类型的锁，包括普通锁、检错锁、递归锁

          * 即当锁处于占用状态时，其他线程会挂起，当锁被释放时，

            所有等待的线程都将被唤醒，再次对锁进行竞争。

            在挂起与释放过程中，涉及用户态与内核态之间的context切

            换，而这种切换是比较消耗性能的。

        * 自旋锁

          自旋锁被某线程占用时，其他线程不会进入睡眠(挂起)状态，而是一直运行（自旋/空转）直到锁被释放。由于不涉及用户态与内核态之间的切换，它的效率远远高于互斥锁。

        * 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。

        * 条件变量可以以原子的方式阻塞进线程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

        * 信号量机制(Semaphore)

        * 信号机制(Signal)

        * 线程间控制

          主要就是线程状态切换通知，如  interrupt() join() notify() yield()

    * 线程池/进程池（线程的复用机制）

      ![线程池](https://github.com/cyanzhao/cyanzhao.github.io/raw/master/_source/线程池.png)

    * 异步编程

      - 异步编程需要解决的问题，具体实现见 python 异步编程

        - 事件循环、回调
        - 多个回调之间的状态管理困难
        - 同步的代码结构

      - 同步 vs 异步（**用户态、任务**）

        - 指的是在用户态，任务之间是否等待，其中异步的实现有多种方式，如：多线程、消息队列、reactor模式、甚至定期询问 fd 是否准备就绪等

      - 堵塞 vs 非阻塞（**线程**）

        -  指的是当前线程是否被阻塞，比如常见的I/O操作、lock等

      - 并发 vs 并行：并行是真正的多核推进

      - 5种网络 IO

        - 阻塞 blocking IO

          ![2阶段网络IO](https://github.com/cyanzhao/cyanzhao.github.io/raw/master/_source/2阶段网络IO.jpg)

        - 非阻塞nonblocking IO

        - 信号驱动signal driven IO

        - 就绪事件通知

          - 维护一个状态，由用户读取，在数据就绪时就生效

          - reactor 模式就是一种利用了**就绪事件通知**原则实现的I/O多路复用模型

            系统调用（like recv()）之前先调用epoll（select poll ），内核准

            备好数据后（这个过程不占用CPU的），通知进程哪几个socket

            有数据，将数据从内核空间copy到进程空间

          - select poll epoll 对比

        - 异步IO

          * 异步IO由系统调用用户的回调函数，直到数据IO完成才发生回调

* 密码学

  - 对称加密

    - DES AES

  - 哈希加密

    - 验证文件完整性
    - 数字签名

  - 非对称加密

    - RSA等

  - 数字证书

    是数字认证机构下发的证书，包含了真实服务器的公钥和网站的其他信息，机构用自己的私钥加密后发给客户端（浏览器），客户端通过机构的公钥解密得到服务器的公钥等信息，这样客户端就能够与从服务器索要的公钥对比，判断服务器是否是可信的

  - 数字签名

    为验证报文的正确性（未被中途篡改）而设计。

    算法是S(H(M))，所以服务器发送的信息是M+数字签名

  - 如何保证通信的可靠性

    - 传输通道是可信的 <数字证书>，通道是可信的是保证数字签名和报文正确的基础
    - 内容未被篡改 <数字签名>
    - 内容是加密的 <非明文>

  - SSH secure shell，openssh

    - 解决计算机之间明文登录的问题
    - 密码登录过程一
      - a请求登录b
      - b将自己签发的公钥发给a
      - a使用公钥将登录密码加密后发给b
      - b使用私钥解密后是正确的登录密码，允许登录
    - 免密登录过程二
      - a将公钥放在需要登录的机器上
      - a请求b时，b发送一段随机字符串
      - a使用私钥加密后发送给b
      - b使用公钥解密解密后与随机字符串相等，允许登录
    - 注意：非对称秘钥对是自己生成的，没有CA公正，登录时需要手动确认主机公钥指纹的正确性